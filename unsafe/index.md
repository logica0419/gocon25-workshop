author: tenntenn
summary: The magic of unsafe package
id: unsafe
categories: codelab,markdown
environments: Web
status: Draft

# Go unsafe Codelab

このコードラボでは、unsafeパッケージについて、解説します。

## 学習目標

- 任意の型のポインタに変換できる
- `uintptr`型を使ったポインタ演算ができる
- `unsafe`パッケージの危険性を理解する

## 進め方

1. 各ステップの「学習内容」を読み、概念を理解します
2. `skeleton/stepX/main.go` にあるTODOコメントを修正し実装します
3. 修正したコードを実行します
4. `solution/stepX/main.go` と比較して理解を深めます

### 前提条件

- 基本的な Go の文法の理解
- ポインタの理解

### 実行して確認

各ステップのコードを修正したら、以下のコマンドで動作を確認してください。

```bash
go run skeleton/stepX/main.go
```

---

## Step 1: `unsafe`パッケージと`unsafe.Pointer`型

### 学習内容

このステップでは、`unsafe.Pointer`を使って通常はアクセスできない非公開フィールドへのアクセス方法を学びます。Goの型安全性を回避し、任意の型のポインタを別の型のポインタに変換する手法を理解します。

### `unsafe`パッケージの役割

`unsafe`パッケージは、Goの型安全性を回避するための低レベル操作を提供します。主な用途としては次のようなものが挙げられます。

- 任意の型のポインタ変換
- メモリレイアウトの直接操作
- 構造体のフィールドオフセット計算
- サイズやアライメントの取得

多くの場合使用を避けるべきですが、パフォーマンスが重要なケースや、`cgo`を用いてC言語との相互運用時に必要となることがあります。

### `unsafe.Pointer`型

`unsafe.Pointer`は特殊なポインタ型で、次のように任意のポインタ型を相互変換が可能になります。

```go
// 任意の型のポインタ -> unsafe.Pointer
var x int64 = 100
p := unsafe.Pointer(&x)

// unsafe.Pointer -> 任意の型のポインタ
y := (*float64)(p)
fmt.Println(*y)
```

### 明示的な`import`宣言が必要な理由

`unsafe`パッケージが言語組み込みではなく、明示的な`import`宣言を必要とする設計には重要な意味があります。

- **意図的な使用の明確化** - 開発者が危険性を理解した上で意図的に使用していることを示し、コードレビューを助ける
- **静的解析での検出** - `import`宣言から`unsafe`パッケージを使用しているコードを機械的に特定できる
- **セキュリティツールでの可視化** - Google Capslock（capability分析ツール）やdeps.dev（依存関係分析サービス）などが`unsafe`使用を特別に可視化し、セキュリティリスクとして警告

この設計により、危険な操作が暗黙的に行われることを防ぎ、コードの監査性を高めています。

### `unsafe`パッケージの危険性

`unsafe`パッケージを使用する際の主なリスクは次の通りです。

1. **型安全性の喪失** - 誤った型変換によるメモリ破壊
2. **プラットフォーム依存** - メモリレイアウトがアーキテクチャによって異なる場合がある
3. **Goランタイムとの非互換** - GC（ガベージコレクタ）やスタック移動により予期しない動作
4. **将来の互換性なし** - Goのバージョンアップで動作しなくなる可能性

**重要な概念**

- `unsafe.Pointer`は任意の型のポインタと相互変換可能
- 型安全性を完全に回避するため、誤用するとプログラムがクラッシュする
- 構造体のメモリレイアウトが同じなら、異なる型として解釈可能

### 実装タスク

このステップでは、パッケージ`pkgA`の非公開フィールドを持つ構造体`A`に対して、`unsafe.Pointer`を使ってアクセスします。

`skeleton/step1/main.go`を修正して、次の要件を満たしてください。

1. 構造体`A`の非公開フィールド`n`と同じメモリレイアウトを持つ構造体`B`を定義
2. `unsafe.Pointer`を使って`*A`を`*B`に変換
3. 構造体`B`経由で値を設定し、`A`のメソッド経由で確認

### 理解度チェック

- なぜ`unsafe.Pointer`を介さずに直接型変換できないのか説明できますか？
- 同じ型のフィールドを持つ構造体であっても、フィールドの宣言順序が異なるとメモリレイアウトが変わります。その場合、どのような問題が発生しますか？
- `unsafe`パッケージが言語組み込みではなく、明示的な`import`宣言を必要とする設計の利点を2つ以上挙げられますか？
- `unsafe.Pointer`の使用を避けるべき理由を3つ以上挙げられますか？

---

## Step 2: 構造体サイズのコンパイル時検証

### 学習内容

このステップでは、Step 1で学んだ構造体の型変換に対して、安全性を高める防御的プログラミングの手法を学びます。構造体のサイズが一致することをコンパイル時に検証し、メモリレイアウトの不一致によるバグを防ぐ方法を理解します。

### なぜサイズチェックが必要か

`unsafe.Pointer`型を使って異なる構造体型に変換する際、両者のメモリレイアウトが同じであることが前提となります。しかし、以下の場合にレイアウトが変わる可能性があります。

- フィールドの型が変更された場合
- フィールドが追加・削除された場合
- パディング（アライメント）が変更された場合

### `unsafe.Sizeof`関数とは

`unsafe.Sizeof`関数は、引数に渡された値や型のメモリ上のサイズをバイト単位で返します。

```go
var x int32
fmt.Println(unsafe.Sizeof(x))        // 4
fmt.Println(unsafe.Sizeof(int64(0))) // 8

type Person struct {
    Name string // 16バイト（64ビット環境）
    Age  int    // 8バイト（64ビット環境）
}
fmt.Println(unsafe.Sizeof(Person{})) // 24
```

`unsafe.Sizeof`関数の重要な特性：

1. **コンパイル時定数** - 結果はコンパイル時に決定され、定数として扱える
2. **型のサイズを返す** - 実際の値の内容ではなく、型自体のサイズ
3. **パディングを含む** - 構造体の場合、アライメント用のパディングも含む
4. **参照型は固定サイズ** - スライスや文字列は内部構造のサイズが返される（要素数に依存しない）

```go
// 基本型のサイズ
fmt.Println(unsafe.Sizeof(true))      // 1 (bool型)
fmt.Println(unsafe.Sizeof(uint8(0)))  // 1
fmt.Println(unsafe.Sizeof(int32(0)))  // 4
fmt.Println(unsafe.Sizeof(int64(0)))  // 8

// ポインタのサイズ（環境依存）
var p *int
fmt.Println(unsafe.Sizeof(p))  // 8（64ビット環境）または4（32ビット環境）
```

### コンパイル時サイズチェックの仕組み

`unsafe.Sizeof`関数がコンパイル時定数であることを利用して、構造体のサイズの差分を検証します。

```go
type B struct {
    N int
}

// 構造体Aと構造体Bのサイズの差分を計算
const delta = int64(unsafe.Sizeof(B{})) - int64(unsafe.Sizeof(pkgA.A{}))

// deltaが0でなければ、配列サイズが負になりコンパイルエラー
var _ [-delta * delta]int
```

この手法のポイントは次の通りです。

1. 差分が0の場合、`-0 * 0 = 0`で配列サイズは0（問題なし）
2. 差分が非0の場合、`-delta * delta`は必ず負になりコンパイルエラー
3. 実行時ではなくコンパイル時に問題を検出できる

### 実際に起きた問題

[Go issue #74462](https://go.dev/issue/74462)では、`golang.org/x/tools`パッケージがこのサイズチェック手法を使用していたため、Go 1.25で古いバージョンのライブラリがビルドできなくなる問題が発生しました。これは`unsafe`パッケージを使用するリスクの実例です。

### 実際のコード例

```go
var a pkgA.A
// サイズチェックが成功した場合のみ、この変換が安全
b := (*B)(unsafe.Pointer(&a))
b.N = 100
fmt.Println(a.N()) // 100
```

**重要な概念**

- 構造体のサイズが一致していても、フィールドの型や順序が異なる場合は危険
- サイズチェックは最低限の安全性を保証する防御策
- `unsafe.Sizeof`関数の結果はコンパイル時に決定される
- 配列の負のサイズを利用したコンパイル時アサーション

### 実装タスク

このステップでは、Step 1のコードにサイズチェックを追加して、より安全なコードにします。

`skeleton/step2/main.go`を修正して、次の要件を満たしてください。

1. Step 1と同じく、構造体`B`型を定義（構造体`A`型の非公開フィールドと同じレイアウト）
2. 構造体`A`型と構造体`B`型のサイズ差分をチェックするコンパイル時アサーションを追加
3. サイズが一致した場合のみ、`unsafe.Pointer`型による変換を実行
4. 構造体`B`型のフィールドを変更して、コンパイルエラーになることを確認

### 理解度チェック

- なぜサイズが同じでも構造体の変換が危険な場合があるか説明できますか？
- `unsafe.Sizeof`関数がコンパイル時定数になる理由を理解していますか？
- `-delta * delta`という式を使う理由を説明できますか？
- この手法で防げるバグと防げないバグをそれぞれ挙げられますか？

---

## Step 3: `uintptr`型とポインタ演算、そして`unsafe.Add`関数

### 学習内容

このステップでは、`uintptr`型を使ったポインタ演算の危険性と、Go 1.17で導入された`unsafe.Add`関数を使った安全な方法を学びます。ポインタを数値として扱うことのリスクと、`go vet`による検出について理解します。

### `uintptr`型とは

`uintptr`型は、ポインタ値を保持できる大きさの符号なし整数型です。

```go
var x int = 42
p := &x
addr := uintptr(unsafe.Pointer(p)) // ポインタを数値に変換
fmt.Printf("アドレス: 0x%x\n", addr)
```

### `uintptr`型を使ったポインタ演算の危険性

`uintptr`型に変換した場合、その値はGC（ガベージコレクタ）に追跡されなくなります。

```go
// 危険なコード
arr := []int{10, 20, 30}
base := uintptr(unsafe.Pointer(&arr[0]))
arr = nil
// この間にGCが発生すると、arrが移動する可能性がある
var _ = (*int)(unsafe.Pointer(base + unsafe.Sizeof(arr[0])))
```

### `go vet`コマンドによる検出

`go vet`コマンドは、[unsafeptr](https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/unsafeptr)解析器を使って、`uintptr`型から`unsafe.Pointer`型への変換を検出します。
なお、`go vet`コマンドが検出しないケースも存在します。

```go
$ go vet main.go
./main.go:11:17: possible misuse of unsafe.Pointer
```

### `unsafe.Add`関数

Go 1.17で追加された`unsafe.Add`関数は、より安全にポインタ演算を行えます。

```go
// 推奨される方法
arr := []int{10, 20, 30}
base := unsafe.Pointer(&arr[0])
arr = nil
second := (*int)(unsafe.Add(base, unsafe.Sizeof(arr[0])))
fmt.Println(*second) // 20
```

### `unsafe.Add`関数の利点

`unsafe.Add`関数を使用する際の主な利点は次の通りです。

1. **`uintptr`型変換の規則を満たす** - `unsafe.Pointer`型のドキュメントで定められた規則（ポインタ演算時の`uintptr`型変換は同一式内で行う）を自動的に満たす
2. **コードの簡潔性** - `uintptr`型変換の往復が不要で、一つの関数呼び出しでポインタ演算が完結
3. **意図が明確** - ポインタに対してオフセットを加算する操作であることが関数名から明示的

**重要な概念**

- `uintptr`型は単なる整数であり、GCはポインタとして追跡しない
- `unsafe.Add`関数は内部でポインタの妥当性を保持する
- スライスの内部構造は言語仕様では保証されないが、実装を理解することは有益

### 実装タスク

このステップでは、Goのスライスが内部的に「配列へのポインタ」「長さ」「容量」の3つのフィールドを持つ構造体として実装されていることを、`unsafe`パッケージを使って確認します。

`skeleton/step2/main.go`を修正して、次の要件を満たしてください。

1. スライスの内部構造を表す構造体`SliceHeader`型を定義
2. `int`型のスライスを作成し、`unsafe.Pointer`型を使って`SliceHeader`型として解釈
3. `unsafe.Add`関数を使って内部配列の各要素に直接アクセス
4. 通常のスライス操作で得られる値（`len`関数、`cap`関数、各要素）と一致することを確認

### 理解度チェック

- `uintptr`型に変換するとGCに追跡されなくなる理由を説明できますか？
- `go vet`コマンドが`unsafe.Pointer`型の誤用を検出する仕組みを理解していますか？
- `unsafe.Add`関数を使うべき場面を2つ以上挙げられますか？

---

## まとめ

### 学んだ概念

**Step 1: `unsafe`パッケージと`unsafe.Pointer`型**

- `unsafe.Pointer`型は任意の型のポインタと相互変換可能
- 非公開フィールドへのアクセスが可能だが、型安全性を失う
- 明示的な`import`宣言により、危険な操作が可視化される設計

**Step 2: 構造体サイズのコンパイル時検証**

- `unsafe.Sizeof`関数はコンパイル時定数として評価される
- 配列の負のサイズを利用したコンパイル時アサーション
- 防御的プログラミングによりランタイムエラーを事前に防ぐ

**Step 3: `uintptr`型とポインタ演算、そして`unsafe.Add`関数**

- `uintptr`型に変換するとGCに追跡されなくなる危険性
- `unsafe.Add`関数により安全なポインタ演算が可能
- スライスの内部構造を理解し、Goランタイムの実装を確認

### 次のステップ

1. 開発しているGoのプロジェクトで`unsafe`パッケージを使用しているものがないか調べてみる
2. `reflect`パッケージと`unsafe`パッケージの組み合わせを理解する
3. 実際のプロダクションコードで`unsafe`パッケージが使われている例を調査する

## 参考資料

- [The Go Programming Language Specification - Package unsafe](https://go.dev/ref/spec#Package_unsafe)
- [unsafe package documentation](https://pkg.go.dev/unsafe)
- [Go issue #74462 - x/tools unsafe usage](https://go.dev/issue/74462)
